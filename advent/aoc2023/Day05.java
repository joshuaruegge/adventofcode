package advent.aoc2023;

import advent.utilities.general.*;

import java.util.LinkedList;

public class Day05 implements IDay {

    static String input;

    public static void main(String[] args) {
        input = Input.fetchInput(2023, 5);
        DayRunner.run(new Day05());
    }

    @Override
    public String part1() {
        String[] maps = input.split("\n\n");
        LinkedList<Long> numbers = new LinkedList<>();
        String[] seeds = maps[0].split(" ");
        for (int i = 1; i < seeds.length; i++)
            numbers.add(Long.parseLong(seeds[i]));
        for (int i = 1; i < maps.length; i++) {
            LinkedList<Long> nextNumbers = new LinkedList<>();
            for (long l : numbers)
                nextNumbers.add(map(l, maps[i].split("\n")));
            numbers = nextNumbers;
        }
        return Long.toString(numbers.stream().min(Long::compare).get());
    }

    @Override
    public String part2() {
        String[] maps = input.split("\n\n");
        String[] seeds = maps[0].split(" ");
        LinkedList<Pair<Long,Long>> ranges = new LinkedList<>();

        //initialize seed ranges
        for (int seed = 1; seed < seeds.length; seed += 2) {
            long start = Long.parseLong(seeds[seed]);
            long range = Long.parseLong(seeds[seed + 1]);
            ranges.add(new Pair<>(start, start + range));
        }

        //iterate over each map and update ranges
        for (int mapIndex = 1; mapIndex < maps.length; mapIndex++) {
            String[] lines = maps[mapIndex].split("\n");

            //appendRanges holds new ranges that can't collide with remaining sections
            LinkedList<Pair<Long, Long>> appendRanges = new LinkedList<>();
            //iterate over ranges in map
            for (int lineIndex = 1; lineIndex < lines.length; lineIndex++) {
                String[] nums = lines[lineIndex].split(" ");

                long srcStart = Long.parseLong(nums[1]);
                long destStart = Long.parseLong(nums[0]);
                long range = Long.parseLong(nums[2]);
                long diff = destStart - srcStart;

                long srcEnd = srcStart + range;
                //newRanges holds ranges generated by collecting this line's collision with all existing ranges
                LinkedList<Pair<Long, Long>> newRanges = new LinkedList<>();
                for (Pair<Long, Long> oldRange : ranges) {
                    long oldStart = oldRange.key;
                    long oldEnd = oldRange.value;
                    //generate range for before overlap, overlap, and after overlap
                    //if a range exists after "cut"/overlap procedure, its 2nd value will be greater than its first
                    //this is handy because if no overlap exists, then either before or after (depending on order)
                    //will hold same value as oldRange, and the other two will be invalid and ignored
                    Pair<Long, Long> before = new Pair<>(oldStart, Math.min(oldEnd, srcStart));
                    Pair<Long, Long> overlap = new Pair<>(Math.max(oldStart, srcStart), Math.min(oldEnd, srcEnd));
                    Pair<Long, Long> after = new Pair<>(Math.max(srcEnd, oldStart), oldEnd);
                    //stick resulting ranges back in if valid
                    //before and after retain their original values
                    if (before.value > before.key) newRanges.add(before);
                    if (after.value > after.key) newRanges.add(after);
                    //overlap represents a "map" taking place, where values of the source become new value in dest
                    //therefore, add the "actual" range of value+diff (diff is calculated difference/offset)
                    //however, these new overlapped mappings exist in the "next" mapping space, not the current one
                    //therefore, we cant be checking for collisions with them until the next map
                    //thus, shove them in a separate list to append at the end
                    if (overlap.value > overlap.key) appendRanges.add(new Pair<>(overlap.key + diff, overlap.value + diff));

                }
                ranges = newRanges;
            }
            ranges.addAll(appendRanges);
        }
        //now that all mappings have taken place, ranges contains all potential location values
        //so, just get the smallest starting range value
        return Long.toString(ranges.stream().map(c -> c.key).min(Long::compare).get());
    }

    //parses the given long through the rules of the provided map
    public long map(long start, String[] map) {
        for (int m = 1; m < map.length; m++) {
            String[] nums = map[m].split(" ");
            long srcStart = Long.parseLong(nums[1]);
            long destStart = Long.parseLong(nums[0]);
            long range = Long.parseLong(nums[2]);
            long diff = destStart - srcStart;

            if (start >= srcStart && start < srcStart + range) {
                return start + diff;
            }
        }
        return start;
    }
}
