package advent.aoc2023;

import advent.utilities.general.*;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;

public class Day05 implements IDay {

    static String input;

    public static void main(String[] args) {
        input = Input.fetchInput(2023, 5);
        DayRunner.run(new Day05());
    }

    static String input2 = " ";

    @Override
    public String part1() {
        String[] maps = input.split("\n\n");
        ArrayList<Long> vals = new ArrayList<>();
        String[] seeds = maps[0].split(" ");
        for(int i = 1; i < seeds.length; i++)
            vals.add(Long.parseLong(seeds[i]));
        for(int i = 1; i < maps.length; i++) {
            ArrayList<Long> newVals = new ArrayList<>();
            for(long l : vals)
                newVals.add(map(l, maps[i].split("\n")));
            vals = newVals;
        }
        return Long.toString(Collections.min(vals));
    }

    public long map(long start, String[] map) {
        long end = start;
        for(int m = 1; m < map.length; m++) {
            String[] nums = map[m].split(" ");
            long srcStart = Long.parseLong(nums[1]);
            long destStart = Long.parseLong(nums[0]);
            long range = Long.parseLong(nums[2]);
            long diff = destStart - srcStart;

            if(start >= srcStart && start < srcStart + range) {
                end = start + diff;
                break;
            }
        }
        return end;
    }
    @Override
    public String part2() {
        String[] maps = input.split("\n\n");
        String[] seeds = maps[0].split(" ");
        ArrayList<CoordL> ranges = new ArrayList<>();

        //initialize seed ranges
        for(int seed = 1; seed < seeds.length; seed += 2) {
            long start = Long.parseLong(seeds[seed]);
            long range = Long.parseLong(seeds[seed+1]);
            ranges.add(new CoordL(start,start+range));
        }

        //iterate over each map and update ranges
        for(int mapIndex = 1; mapIndex < maps.length; mapIndex++) {
            String[] lines = maps[mapIndex].split("\n");

            //appendRanges holds new ranges that won't collide with remaining sections
            ArrayList<CoordL> appendRanges = new ArrayList<>();
            //iterate over ranges in map
            for(int lineIndex = 1; lineIndex < lines.length; lineIndex++) {
                String[] nums = lines[lineIndex].split(" ");
                long srcStart = Long.parseLong(nums[1]);
                long destStart = Long.parseLong(nums[0]);
                long range = Long.parseLong(nums[2]);
                long diff = destStart - srcStart;

                long srcEnd = srcStart + range;
                //newRanges holds ranges generated by collecting this line's collision with all existing ranges
                ArrayList<CoordL> newRanges = new ArrayList<>();
                for(CoordL oldRange : ranges) {
                    //generate range for before overlap, overlap, and after overlap
                    //if a range exists after "cut"/overlap procedure, its 2nd value will be greater than its first
                    //this is handy because if no overlap exists, then either before or after (depending on order)
                    //will hold same value as oldRange, and the other two will be invalid and ignored
                    CoordL before = new CoordL(oldRange.x, Math.min(oldRange.y, srcStart));
                    CoordL overlap = new CoordL(Math.max(oldRange.x, srcStart), Math.min(oldRange.y, srcEnd));
                    CoordL after = new CoordL(Math.max(srcEnd, oldRange.x), oldRange.y);
                    //stick resulting ranges back in if valid
                    //before and after retain their original values
                    if(before.y > before.x)
                        newRanges.add(before);
                    //overlap represents a "map" taking place, where values of the source become new value in dest
                    //therefore, add the "actual" range of value+diff (diff is calculated difference/offset)
                    //however, these new overlapped mappings exist in the "next" mapping space, not the current one
                    //therefore, we cant be checking for collisions with them until the next map
                    //thus, shove them in a separate list to append at the end
                    if(overlap.y > overlap.x) {
                        appendRanges.add(new CoordL(overlap.x+diff, overlap.y+diff));
                    }
                    if(after.y > after.x) {
                        newRanges.add(after);
                    }
                }
                ranges = newRanges;
            }
            ranges.addAll(appendRanges);
        }
        //now that all mappings have taken place, ranges contains all potential location values
        //so, just get smallest starting range value
        return Long.toString(ranges.stream().map(c -> c.x).min(Long::compare).get());
    }
}
